% LaTeX source for textbook ``ThinkCPP , a game perspective''
% Copyright (C) 2023  Lisa Patacchiola and Allen B Downey


\chapter{Variables and types}

\section{More output}
\index{output}
\index{statement!output}

As I mentioned in the last chapter, you can put as many statements as
you want in {\tt main}.  For example, to output more than one line:

\begin{lstlisting}
#include <iostream>

// main: generate some simple output

int main ()
{
  // output 1 line
  std::cout << "Hello, world." << std::endl; 
  
  // output 1 more
  std::cout << "How are you?" << std::endl; //great!  
  return 0;
}
\end{lstlisting}

As you can see, it is legal to put comments at the
end of a line, as well as on a line by themselves.

\index{replit}
If you want to try that with the replit code, go back to the project link 
\url{https://replit.com/@lpatacch/helloWorld#hello.cpp}. Then, look for a button on the right hand of the screen with the words "Fork Repl". It should look like Figure \ref{fig:fork}
\begin{figure}
    \centering
    \includegraphics{fork}
    \caption{The Fork button on Replit}
    \label{fig:fork}
\end{figure}
You now should have a copy of the code that you can change any way you want.

\index{string}
\index{type!string}

In the program. the phrases that appear in quotation marks are called {\bf strings},
because they are made up of a sequence (string) of letters.  Actually,
strings can contain any combination of letters, numbers, punctuation
marks, and other special characters.

\index{newline}

Often it is useful to display the output from multiple output
statements all on one line.  You can do this by leaving out
the first {\tt endl}:

\begin{lstlisting}
int main ()
{
  std::cout << "The game ";
  std::cout << "is about to start!" << std::endl;
  return 0
}
\end{lstlisting}

In this case the output appears on a single line as
{\tt The game is about to start!}.  Notice that there is a space
between the word ``game'' and the second quotation mark.
This space appears in the output, so it affects the behavior
of the program.

Spaces that appear outside of quotation marks generally do
not affect the behavior of the program.  For example, I
could have written:

\begin{lstlisting}
int main ()
{
  std::cout<<"The game";
  std::cout<<" is about to start!"<<     std::endl;
  return 0;
}
\end{lstlisting}

This program would compile and run just as well as the original.
The breaks at the ends of lines (newlines) do not affect
the program's behavior either, so I could have written:

\begin{lstlisting}
int main(){std::cout<<"The game ";std::cout<<
    "is about to start!"<< std::endl;return 0;}
\end{lstlisting}

That would work, too, although you have probably noticed that
the program is getting harder and harder to read.  Newlines and
spaces are useful for organizing your program visually, making
it easier to read the program and locate syntax errors.

\subsection{Escape Sequences}
There are special character sequences that can be put in a string
that will act differently than other characters. They are called
escape sequences. One popular escape sequence is '\textbackslash n'. This character
is very similar to std::endl. When printed, it goes to the next line.
For example, this code:
\begin{lstlisting}
#include <iostream>

// main: generate some simple output

int main ()
{
  // This prints in 2 lines
  std::cout << "Hello, world. \n How are you?" << std::endl;  
  return 0;
}
\end{lstlisting}
Displays the following:
\begin{verbatim}
Hello, world.
 How are you?
\end{verbatim}
There are other characters that can be helpful. I put some of the most
popular in the table below.
\begin{table}[h]
\centering
\begin{tabular}{ | c | l | }
\hline
 Escape Character & Behavior \\\hline
 \textbackslash n & Goes to the next line \\ 
 \textbackslash t & Creates a horizontal tab \\  
 \textbackslash\textbackslash &  Displays the slash character \\
 \textbackslash" & Displays the double quote character \\
\hline
\end{tabular}
    \caption{Escape characters and behavior}
    \label{tab:escapechar}
\end{table}
\section{Values}
\index{value}
\index{type}

A value is one of the fundamental things---like a letter or
a number---that a program manipulates.  The only values we have
manipulated so far are the string values we have been outputting, like
{\tt "Hello, world."}.  You (and the compiler) can identify
string values because they are enclosed in quotation marks.

There are other kinds of values, including integers and characters.
An integer is a whole number like 1 or 17.  You can output
integer values the same way you output strings:

\begin{verbatim}
  std::cout << 17 << std::endl;
\end{verbatim}

A character value is a letter or digit or punctuation mark
enclosed in single quotes, like {\tt 'a'} or {\tt '5'}.
You can output character values the same way:


\begin{verbatim}
  std::cout << '}' << std::endl;
\end{verbatim}

This example outputs a single close curly-brace on a line
by itself.

It is easy to confuse different types of values, like {\tt "5"}, {\tt
'5'} and {\tt 5}, but if you pay attention to the punctuation, it
should be clear that the first is a string, the second is a character
and the third is an integer.  The reason this distinction is important
should become clear soon.

\section {Variables}
\index{variable}
\index{value}

One of the most powerful features of a programming language is the
ability to manipulate {\bf variables}.  A variable is a named location
that stores a value.  

Just as there are different types of values (integer, character,
etc.), there are different types of variables.  When you create a new
variable, you have to declare what type it is.  For example, the
character type in C++ is called {\tt char}.  The following statement
creates a new variable named {\tt sarah} that has type {\tt char}.

\begin{verbatim}
    char sarah;
\end{verbatim}

This kind of statement is called a {\bf declaration}.

The type of a variable determines what kind of values it can
store.  A {\tt char} variable can contain characters, and it should
come as no surprise that {\tt int} variables can store integers.

There are several types in C++ that can store string values, but we
are going to skip that for now (see Chapter~\ref{strings} if you want to see it now).

\index{declaration}
\index{statement!declaration}

To create an integer variable, the syntax is 

\begin{verbatim}    
    int bob;
\end{verbatim}

%
where {\tt bob} is the arbitrary name you made up for the
variable.  In general, you will want to make up variable names
that indicate what you plan to do with the variable.  For
example, if you saw these variable declarations:

\begin{lstlisting}
    char firstLetter;
    char lastLetter;
    int hour, minute;
\end{lstlisting}
%
you could probably make a good guess at what values
would be stored in them.  This example
also demonstrates the syntax for declaring multiple variables
with the same type: {\tt hour} and {\tt minute}
are both integers ({\tt int} type).

\section{Assignment}
\index{assignment}
\index{statement!assignment}

Now that we have created some variables, we would like to
store values in them.  We do that with an {\bf assignment
statement}.


\begin{lstlisting}
    firstLetter = 'a';   // give firstLetter the 
                         // value 'a'
    hour = 11;           // assign the value 11 to hour
    minute = 59;         // set minute to 59
\end{lstlisting}
%
This example shows three assignments, and the comments show
three different ways people sometimes talk about assignment
statements.  The vocabulary can be confusing here, but the
idea is straightforward:

\begin{itemize}

\item When you declare a variable, you create a named storage location.

\item When you make an assignment to a variable, you give it a value.

\end{itemize}

A common way to represent variables on paper is to draw a box
with the name of the variable on the outside and the value
of the variable on the inside.  This kind of figure is called
a {\bf state diagram} because is shows what state each of the
variables is in (you can think of it as the variable's ``state of
mind'').
This diagram shows
the effect of the three assignment statements:

\vspace{0.1in}
\centerline{\epsfig{figure=oldimages/assign.eps}}
\vspace{0.1in}

\index{rules!variable value}
I sometimes use different shapes to indicate different
variable types.  These shapes should help remind you that one of the
rules in C++ is that a variable has to have the same type as the
value you assign it.  For example, you cannot store a string in
an {\tt int} variable.  The following statement generates a compiler
error.

\begin{lstlisting}
  int hour;
  hour = "Hello.";       // WRONG !!
\end{lstlisting}

%
This rule is sometimes a source of confusion because there are many
ways that you can convert values from one type to another, and C++
sometimes converts things automatically.  But for now, you should
remember that, as a general rule, variables and values should have the same
type, and we'll talk about special cases later.

Another source of confusion is that some strings {\em look}
like integers, but they are not.  For example,
the string {\tt "123"}, which is made up of the
characters {\tt 1}, {\tt 2} and {\tt 3}, is not
the same thing as the {\em number} {\tt 123}.
This assignment is illegal:

\begin{verbatim}
  minute = "59";         // WRONG!
\end{verbatim}
%
\section{Initialization}
When variables are created, they can be set to a value immediately instead of waiting until later. This can shorten your code. 

\subsection{Legacy}
Pre-C++ 11, it was quite common to use an equation to initialize 
your variables.
Here is an example:
\begin{verbatim}
  int hitPoints = 10;
\end{verbatim}
Most of our examples use this format because people are used to 
this style when using other computer languages. But, C++11 and later
have a different style that can be used instead.
\subsection{Braced}
This new style is called braced initialization. Instead of having an equal sign, the line is even shorter. Although it does the same thing as the equal sign, it can help with some common programming errors. We will be talking about this in later chapters.
\begin{verbatim}
  int hitPoints{10};
\end{verbatim}
\index{braced initialization}
\index{initalization!braced}
\section{Outputting variables}
\label{output}

You can output the value of a variable using the same commands
we used to output simple values.

\begin{lstlisting}
  int hour, minute;
  char colon;

  hour = 11;
  minute = 59;
  colon = ':';

  std::cout << "The battle will start at  ";
  std::cout << hour;
  std::cout << colon;
  std::cout << minute;
  std::cout << std::endl;
\end{lstlisting}

%
Try this project here:\url{https://replit.com/@lpatacch/OutputVariables#outvar.cpp}.
This program creates two integer variables named {\tt hour} and {\tt
minute}, and a character variable named {\tt colon}.  It assigns
appropriate values to each of the variables and then uses a series
of output statements to generate the following:

\begin{verbatim}
The battle will start at 11:59
\end{verbatim}

When we talk about ``outputting a variable,'' we mean outputting the
{\em value} of the variable.  To output the {\em name} of a variable,
you have to put it in quotes.  For example: {\tt std::cout << "hour";}

As we have seen before, you can include more than one value in
a single output statement, which can make the previous program more
concise:

\begin{lstlisting}
  int hour, minute;
  char colon;

  hour = 11;
  minute = 59;
  colon = ':';

  std::cout << "The battle will start at " << hour 
                << colon << minute << std::endl;
\end{lstlisting}
%
On one line, this program outputs a string, two integers, a character,
and the special value {\tt endl}.  Very impressive!

\subsection{Format}
There is a new way to output values in C++20\footnote{There are different
versions of C++, named for the year that they were approved. C++20 was
approved in 2020.} called Format. It is a
more recent method (so new that at the time of this writing, it was not
supported by some compilers, including Replit.) If 
you try this code and get a compiler error that "error: no member 
named 'format' in namespace 'std'," it may not be supported in your development environment yet.

If this is supported \footnote{If you are looking for a development environment that supports format, the following code 
was tested on Visual Studio Code using the Microsoft compiler.}, this is a different way for you to be able
to output variables. To get the following code to work,
you will need to have the line:
\begin{verbatim}
#include <format>  
\end{verbatim}
up where your "\#include \textless iostream\textgreater" line is.

To use format, you will be putting \{\} where you want your values
to be placed. The above example could be changed to this:
\begin{lstlisting}
int hour, minute;
char colon;

hour = 11;
minute = 59;
colon = ':';

std::cout << std::format(
 "The battle will start at {}{}{}.\n", 
    hour, colon, minute);
\end{lstlisting}
The first variable will be put where the first {} is, the second in
the second {} and so on. If you want, you can even number the 
braces, to make it easier to see what variable will be output where.
\begin{lstlisting}
std::cout << std::format(
  "The battle will start at {0}{2}{1}.\n", 
    hour, minute, colon);  
\end{lstlisting}
The first variable will be at the 0 slot, the second will be at the
1 slot, and the third with be at the 2 slot. 

This method is an excellent way to output values, but because it is yet to be available
for all environments, the following examples in the book will not use it. If you prefer this method, it is perfectly fine to use this instead of the one in the other examples.

\section{Variable Naming Rules}
\index{variable naming rules}
\index{variable!naming rules}
\index{rules!variable naming}
A few sections ago, I said that you can make up any name you
want for your variables, but that's not quite true. There are certain rules that you need to follow.
\begin{enumerate}
    \item The name can not start with a number. (It is ok for a number to be in the name, it just can't be the first letter.)
    \item No spaces in the name
    \item Capitalization matters (num is different than NUM) 
    \item No special characters can be in the name other than underscore.
\end{enumerate}

Here are some examples of variables that do not follow the naming rules, and what you can use instead
\begin{lstlisting}[frame=single]
    int 3player;    \\ WRONG, can not start with a 
                    \\ number
    int player3;    \\ This would work
    int my3player   \\ This will also work
    
    int hit points; \\ WRONG, spaces not allowed in the 
                    \\ name
    int hitPoints;  \\ This would work
    int hit_points; \\ This also would work
    
    int cash$;      \\ This would not work because of 
                    \\ $sign
    int cashMoney;  \\ changed to use words instead
\end{lstlisting}
\subsection{Keywords}
\index{keyword}
In addition, there
are certain words that are reserved in C++ because they are
used by the compiler to parse the structure of your program,
and if you use them as variable names, it will get confused.
These words, called {\bf keywords}, include {\tt int},
{\tt char}, {\tt void}, {\tt endl} and many more.

The complete list of keywords is included in the C++ Standard, which
is the official language definition adopted by the the International
Organization for Standardization (ISO) \footnote{There are many versions
of this standard. The language has been adding more and more features over
time. There is information in the Appendix on how to switch the version of the
standard you are using.}.  You
can download a copy electronically from
\bigskip

    \url{http://www.ansi.org/}
%
\bigskip

Rather than memorize the list, I would suggest that you
take advantage of a feature provided in many development
environments: code highlighting.  As you type, different
parts of your program should appear in different colors.  For
example, keywords might be blue, strings red, and other code
black.  If you type a variable name and it turns blue, watch
out!  You might get some strange behavior from the compiler.

\section{Operators}
\index{operator}

{\bf Operators} are special symbols that are used to represent
simple computations like addition and multiplication.  Most
of the operators in C++ do exactly what you would expect them
to do, because they are common mathematical symbols.  For
example, the operator for adding two integers is {\tt +}.

The following are all legal C++ expressions whose meaning is
more or less obvious:

\begin{verbatim}
1+1        hour-1       hour*60 + minute     minute/60
\end{verbatim}
%
Expressions can contain both variables
names and integer values.  In each case the name of the variable is
replaced with its value before the computation is performed.

\index{expression}

\subsection{Not all the math operators}
Although some of the arithmetic operators that you would expect are there, there are some that do not work in C++. Here are a few examples of what does not work, and how to write it in a different way.


\begin{lstlisting}[frame=single]
    int powerUpLevel = 2;
    int damageLevel = 3;
    
    int damageGiven = powerUpLeveldamageLevel;   
        // WRONG 
        // You can't just put variables next to each 
        // other to have them multiply
        
    int damageGiven = powerUpLevel x damageLevel;  
        // WRONG 
        // You can't use x as a multiplication sign. It 
        // is often used as a variable
        
    int damageGiven = powerUpLevel * damageLevel; 
        // Correct!
        // When you multiply, you should use the * symbol
    
    int valToPower = powerUpLevel^2;        // WRONG
        // Although you can use the ^ symbol for a 
        // particular math operation, it is not to 
        // calculate the square (or any other power)
        // We will see this later in the book
        
    int valToPower = powerUpLevel * powerUpLevel; 
        // Correct! 
        // To square a number, you can multiply it with
        // itself
        // There is also another way to do this which we
        // will see later
        
    int percentHurt = damageGiven/100;      // Correct
        // To divide, we should use the / symbol
        // There is something about this that is an 
        // issue, that we will talk about right now.
\end{lstlisting}
%
Also, this symbol should not be used in code -- $\div$. Code does not know what to do with it, so you should use the other method for division.

\subsection{Integer Division}
Addition, subtraction and multiplication all do what you
expect, but you might be surprised by division.  For example,
the following program:

\begin{lstlisting}
  int hour, minute;
  int hitpoints = 49;
  hour = 11;
  minute = 59;
  
  std::cout << "Number of minutes since the midnight";
  std::cout<<" battle: "<< hour*60 + minute << std::endl;

  // This is integer division, so the result will be zero
  std::cout << "Fraction of hitpoints left ";
  std::cout << hitpoints/50 << std::endl;
\end{lstlisting}
%

would generate the following output:

\begin{verbatim}
  Number of minutes since the midnight battle: 719
  Fraction of the hitpoints left: 0
\end{verbatim}
%
Try it yourself here: \url{https://replit.com/@lpatacch/IntegerDivision#intdiv.cpp}.
The first line is what we expected, but the second line is
odd.  The value of the variable {\tt hitpoints} is 49, and
49 divided by 50 is 0.98, not 0.  The discrepancy is because
C++ is performing {\bf integer division}.

\index{type!int}
\index{integer division}
\index{arithmetic!integer}
\index{division!integer}
\index{operand}

When both of the {\bf operands} are integers (operands are the things
operators operate on), the result must also be an integer,
and by definition, integer division always rounds {\em down},
even in cases like this where the next integer is so close.

A possible alternative, in this case, is to calculate a percentage
rather than a fraction:

\begin{lstlisting}
  std::cout << "Percentage of the hitpoints left:";
  std::cout << " " << hitpoints*100/50 << std::endl;
\end{lstlisting}

%
The result is:

\begin{verbatim}
    Percentage of the hitpoints left: 98
\end{verbatim}
%
Again the result is rounded down, but at least now the answer
is approximately correct.  To get an even more accurate
answer, we could use a different type of variable, called
floating-point, that is capable of storing fractional values.
We'll get to that soon in Chapter ~\ref{floating-point}.

\subsection{Modulus operator}
\label{modulus}
\index{modulus}
\index{remainder}
\index{operator!modulus}
\index{operator!remainder}
There is another way to get the information that the integer division is not using. That is a new operator called the {\bf modulus}, or {\bf remainder} operator.

The modulus operator works on integers (and integer expressions)
and yields the {\em remainder} when the first operand is divided
by the second.  In C++, the modulus operator is a percent sign,
{\tt \%}.  The syntax is exactly the same as for other operators:

\begin{lstlisting}
  int quotient = 7 / 3;
  int remainder = 7 % 3;
\end{lstlisting}
%
The first operator, integer division, yields 2.  The second
operator yields 1.  Thus, 7 divided by 3 is 2 with 1 left over.

The modulus operator turns out to be surprisingly useful.  For
example, you can check whether one number is divisible by
another: if {\tt x \% y} is zero, then {\tt x} is divisible
by {\tt y}.

Also, you can use the modulus operator to extract the rightmost
digit or digits from a number.  For example, {\tt x \% 10} yields
the rightmost digit of {\tt x} (in base 10).  Similarly
{\tt x \% 100} yields the last two digits.

\section{Order of operations}
\index{precedence}
\index{rules!precedence}
\index{order of operations}

When more than one operator appears in an expression the order
of evaluation depends on the rules of {\bf precedence}.  A
complete explanation of precedence can get complicated, but
just to get you started:

\begin{itemize}

\item Multiplication and division (and modulus) happen before
addition and subtraction.  So {\tt 2*3-1} yields 5, not 4, and {\tt
2/3-1} yields -1, not 1 (remember that in integer division {\tt 2/3}
is 0).

\item If the operators have the same precedence they are evaluated
from left to right.  So in the expression {\tt minute*100/60},
the multiplication happens first, yielding {\tt 5900/60}, which
in turn yields {\tt 98}.  If the operations had gone from right
to left, the result would be {\tt 59*1} which is {\tt 59}, which
is wrong.

\item Any time you want to override the rules of precedence (or
you are not sure what they are) you can use parentheses.  Expressions
in parentheses are evaluated first, so {\tt 2 * (3-1)} is 4.
You can also use parentheses to make an expression easier to
read, as in {\tt (minute * 100) / 60}, even though it doesn't
change the result.

\end{itemize}

\section{Operators for characters}
\index{character operator}
\index{operator!character}

Interestingly, the same mathematical operations that work on
integers also work on characters.  For example,

\begin{lstlisting}
  char letter;
  letter = 'a' + 1;
  std::cout << letter << std::endl;
\end{lstlisting}
%
outputs the letter {\tt b}.  Although it is syntactically legal
to multiply characters, it is almost never useful to do it.

Earlier I said that you can only assign integer values to
integer variables and character values to character variables,
but that is not completely true.  In some cases, C++ converts
automatically between types.  For example, the following is
legal.

\begin{lstlisting}
  int number;
  number = 'a';
  std::cout << number << std::endl;
\end{lstlisting}
%
The result is 97, which is the number that is used internally
by C++ to represent the letter {\tt 'a'}.  However, it is
generally a good idea to treat characters as characters, and
integers as integers, and only convert from one to the other
if there is a good reason.

Automatic type conversion is an example of a common problem in designing a
programming language, which is that there is a conflict between {\bf
formalism}, which is the requirement that formal languages should have
simple rules with few exceptions, and {\bf convenience}, which is the
requirement that programming languages be easy to use in practice.

More often than not, convenience wins, which is usually good for
expert programmers, who are spared from rigorous but unwieldy
formalism, but bad for beginning programmers, who are often baffled
by the complexity of the rules and the number of exceptions.  In this
book I have tried to simplify things by emphasizing the rules and
omitting many of the exceptions.


\section{Composition}
\index{composition}
\index{expression}

So far we have looked at the elements of a programming
language---variables, expressions, and statements---in
isolation, without talking about how to combine them.

One of the most useful features of programming languages
is their ability to take small building blocks and
{\bf compose} them.  For example, we know how to multiply
integers and we know how to output values; it turns out we can
do both at the same time:

\begin{verbatim}
    std::cout << 17 * 3;
\end{verbatim}
%
Actually, I shouldn't say ``at the same time,'' since in reality
the multiplication has to happen before the output, but
the point is that any expression, involving numbers, characters,
and variables, can be used inside an output statement.  We've
already seen one example:

\begin{verbatim}
  std::cout << hour*60 + minute << std::endl;
\end{verbatim}
%
You can also put arbitrary expressions on the right-hand
side of an assignment statement:

\begin{lstlisting}
  int percentage;
  percentage = (hitpoints * 100) / 50;
\end{lstlisting}
%
This ability may not seem so impressive now, but we will see
other examples where composition makes it possible
to express complex computations neatly and concisely.

WARNING: There are limits on where you can use certain
expressions; most notably, the left-hand side of an assignment
statement has to be a {\em variable} name, not an expression.
That's because the left side indicates the storage location
where the result will go.  Expressions
do not represent storage locations, only values.  So the
following is illegal:  {\tt minute+1 = hour;}.

\section{Multiple assignment}
\index{assignment}
\index{statement!assignment}
\index{multiple assignment}

I haven't said much about it, but it is legal in C++ to
make more than one assignment to the same variable.  The
effect of the second assignment is to replace the old value
of the variable with a new value.

\begin{lstlisting}
  int fred = 5;
  std::cout << fred;
  fred = 7;
  std::cout << fred;
\end{lstlisting}
%
The output of this program is {\tt 57}, because the first
time we print {\tt fred} his value is 5, and the second time
his value is 7.

This kind of {\bf multiple assignment} is the reason I
described variables as a {\em container} for values.  When
you assign a value to a variable, you change the contents of
the container, as shown in the figure:

\vspace{0.1in}
\centerline{\epsfig{figure=oldimages/assign2.eps}}
\vspace{0.1in}

When there are multiple assignments to a variable, it is especially
important to distinguish between an assignment statement and a
statement of equality.  Because C++ uses the {\tt =} symbol for
assignment, it is tempting to interpret a statement like {\tt a = b}
as a statement of equality.  It is not!

First of all, equality is commutative, and assignment is not.
For example, in mathematics if $a = 7$ then $7 = a$.  But in
C++ the statement {\tt a = 7;} is legal, and {\tt 7 = a;}
is not.

Furthermore, in mathematics, a statement of equality is true
for all time.  If $a = b$ now, then $a$ will always equal $b$.
In C++, an assignment statement can make two variables equal,
but they don't have to stay that way!

\begin{lstlisting}
  int a = 5;
  int b = a;     // a and b are now equal
  a = 3;         // a and b are no longer equal
\end{lstlisting}
%
The third line changes the value of {\tt a} but it does not
change the value of {\tt b}, and so they are no longer equal.
In many programming languages, an alternate symbol is used
for assignment, such as {\tt <-} or {\tt :=}, in order to
avoid confusion.

Although multiple assignment is frequently useful, you should
use it with caution.  If the values of variables are changing
constantly in different parts of the program, it can make
the code difficult to read and debug.

% FIXME - should I include the UFO operator here?
\section{Exercises}
\subsection{Hello World}
You have seen hello world a few times by now. Can you recreate it in this Parson Problem? 
\url{https://lpatacch.github.io/thinkCPPGamesEx/HelloParsonsPractice.html} 
\subsection{Modulus Practice}
If you have problems understanding how the modulus operator works, try this small web application.
\url{https://lpatacch.github.io/thinkCPPGamesEx/ModPractice.html}
\subsection{Game HighScore}
For this program, you will practice using characters, cin and cout. Start your program
with the typical main function. Create three
variables - one for the first initial, second
for the last initial, and third to hold a high
score. Next, write code that asks the user to
enter their first initial. Write code that
puts that value in the first initial variable. 
Write similar code for the last initial. Then,
ask the user to enter their high score and place
it in the high score variable. Then, you will
print a line that says "High Scores," then
the next line will have the first and last initial and then the score.
\begin{itemize}
    \item Remember to use appropriate variable types for storing the player's name and game score.
\item Use descriptive variable names and comments in your code to improve its readability.
\item Test your program with different inputs to ensure it handles various scenarios correctly.
\end{itemize}

\subsection{Validation}
% Checksums with UPC numbers
Computers have to deal with numbers a lot. There are messages that are sent to and from the internet. In order to make sure the numbers were entered or received properly, programs usually
run the values through a "validator". This makes sure that the
number that the program has makes sense. One method to 
do validation is called a "check digit". This is an extra number
put at the end of an ID number to see if the number could
be valid. These digits were originally made to check if a 
person typed in an ID correctly, but has been used by programs
to see if a data file or message was corrupted. The check digit
method we are going to use has to do with UPC's. UPC numbers are IDs that are connected to products. It is a way to uniquely identify an item that is sold.

Your friend has a website where people can list the games that
they are willing to let other people borrow or purchase. He
originally let people type in the UPC numbers, but a few of 
them do not seem to be correct. He has asked you to make a 
UPC validator program so he does not have to look up as many 
numbers.

You found out the following information. UPC's have 12 digits.
The first 11 digits are the product number and the number to the
far right is the "check" digit. To calculate the digit, it does
the following:
\begin{enumerate}
    \item Take the odd number digits (first, third, fifth, etc.), add them together and multiply them by three.
    \item Take the even number digits and add them together
    \item Add those two numbers together
    \item Mod that number by 10. (Use the remainder operator)
    \item Take 10 and subtract the number you have and mod it by 10. 
\end{enumerate}
The number that results is the check digit.

Here is an example: A game (Teenage Mutant Ninja Turtles: The Cowabunga Collection - PlayStation 4) has the UPC number of:
083717203469
\begin{enumerate}
    \item The odd digits are: 0+3+1+2+3+6. The sum is 15. 3*15 is 45
    \item The even digits are: 8+7+7+0+4. (We do not use the check digit in the calculation). The sum is 26.
    \item 45+26 = 71
    \item 71 \% 10 = 1
    \item (10-1) \% 10 = 9
\end{enumerate}
9 was the digit that was the last number, so it IS a valid UPC 
number.

For your program, the first version will ask for each digit
of the UPC and put it in a different variable. (For example,
the first number can be placed in an int variable named dig1, 
the second in dig2). Using those variables, create the code
to do the math described above and have it print the check
digit you calculated. Try putting the example UPC
and see if it also comes up with the number 9. Then, try a
UPC number that you have around the house. Did it work?

For an extra challenge, have the user enter the number as
an integer (instead of 12 integers) and from that number
calculate the digits and put the results in your variables.
The program can then use the equation you have already made.
HINT: You can use division and modulus operators to get
each digit.

This program can be made even better if you could tell the
user if the value that was entered as the check digit was 
correct. This type of branching code will be introduced in 
the next chapter (\ref{conditional}).
\section{Glossary}
\begin{description}

\item[variable:] A named storage location for values.  All
variables have a type, which determines which values it can
store.

\item[value:] A letter, or number, or other thing that can be
stored in a variable.  

\item[type:] A set of values.  The types
we have seen are integers ({\tt int} in C++) and characters ({\tt
char} in C++).

\item[keyword:]  A reserved word that is used by the compiler
to parse programs.  Examples we have seen include {\tt int},
{\tt void} and {\tt endl}.

\item[statement:] A line of code that represents a command or
action.  So far, the statements we have seen are declarations,
assignments, and output statements.

\item[declaration:] A statement that creates a new variable and
determines its type.

\item[assignment:] A statement that assigns a value to a variable.

\item[expression:] A combination of variables, operators and
values that represents a single result value.  Expressions also
have types, as determined by their operators and operands.

\item[operator:] A special symbol that represents a simple
computation like addition or multiplication.

\item[modulus:]  An operator that works on integers and yields
the remainder when one number is divided by another.  In C++
it is denoted with a percent sign ({\tt \%}).

\item[operand:] One of the values on which an operator operates. 

\item[precedence:] The order in which operations are evaluated.

\item[composition:] The ability to combine simple
expressions and statements into compound statements and expressions
in order to represent complex computations concisely.

\item[tab:] A special character, written as \verb+\t+ in C++,
that causes the cursor to move to the next tab stop on the
current line.

\index{variable}
\index{value}
\index{type}
\index{keyword}
\index{statement}
\index{assignment}
\index{expression}
\index{operator}
\index{modulus}
\index{operand}
\index{composition}
\index{tab}

\end{description}


